#!/usr/bin/env bash

set -eo pipefail

[[ $DOKKU_TRACE ]] && set -x

# Heroku has opinions on indentation, let's respect them
indent() {
  sed -u 's/^/       /'
}

BUILD_DIR=$1  # -> temp dir that contains whatever is in the git repo
CACHE_DIR=$2  # -> use this dir for caching between compiles
ENV_DIR=$3  # -> environment variables are stored as files inside here

# make sure dirs exist
mkdir -p $CACHE_DIR

if [ ! -f "$BUILD_DIR/.heroku/python/bin/python" ]; then
    echo "-----> This buildpack depends on heroku-buildpack-python."
    echo "You need to run heroku-buildpack-python before heroku-buildpack-buildout" | indent
    exit 1
fi

# support for buildouts using collective.recipe.environment to set credentials
# for third party PyPI installations
if [ -f $ENV_DIR/PYPICLOUD_USERNAME ] && [ -f $ENV_DIR/PYPICLOUD_PASSWORD ]; then
    echo "-----> Use PYPICloud"
    export "PYPICLOUD_USERNAME=$(cat $ENV_DIR/PYPICLOUD_USERNAME)"
    export "PYPICLOUD_PASSWORD=$(cat $ENV_DIR/PYPICLOUD_PASSWORD)"
fi

echo "-----> Use build cache"
if [ -f $CACHE_DIR/eggs.tgz ]; then
    echo "Get buildout results from the previous build" | indent
    tar xfz $CACHE_DIR/eggs.tgz -C $BUILD_DIR/
    tar xfz $CACHE_DIR/parts.tgz -C $BUILD_DIR/
else
    echo "Cache empty, start from scratch" | indent
fi

#if [ -d $CACHE_DIR/bin ]; then
#    echo "Get buildout results from the previous build" | indent
#    cp -r $CACHE_DIR/bin  $BUILD_DIR/
#    cp -r $CACHE_DIR/eggs  $BUILD_DIR/
#    cp -r $CACHE_DIR/parts  $BUILD_DIR/
#    if [ -d $BUILD_DIR/var ]; then
#        cp -r $CACHE_DIR/var  $BUILD_DIR/
#    fi
#else
#    echo "Cache empty, start from scratch" | indent
#fi

echo "-----> Read BUILDOUT_CFG from env vars, or use default"
if [ -f $ENV_DIR/BUILDOUT_CFG ]; then
    export "BUILDOUT_CFG=$(cat $ENV_DIR/BUILDOUT_CFG)"
    echo "Found ${BUILDOUT_CFG}" | indent
else
    export "BUILDOUT_CFG=buildout.cfg"
    echo "Using default: buildout.cfg" | indent
fi

echo "-----> Read BUILDOUT_VERBOSITY from env vars, or use default"
if [ -f $ENV_DIR/BUILDOUT_VERBOSITY ]; then
    export "BUILDOUT_VERBOSITY=$(cat $ENV_DIR/BUILDOUT_VERBOSITY)"
    echo "Use buildout verbosity: ${BUILDOUT_VERBOSITY}" | indent
else
    export "BUILDOUT_VERBOSITY="
    echo "Use default buildout verbosity" | indent
fi

echo "-----> Read BOOTSTRAP_VERBOSITY from env vars, or use default"
if [ -f $ENV_DIR/BOOTSTRAP_VERBOSITY ]; then
    export "BOOTSTRAP_VERBOSITY=$(cat $ENV_DIR/BOOTSTRAP_VERBOSITY)"
    echo "Use bootstrap verbosity: ${BOOTSTRAP_VERBOSITY}" | indent
else
    export "BOOTSTRAP_VERBOSITY="
    echo "Use default bootstrap verbosity" | indent
fi

echo "-----> Read PIP_VERSION from env vars, or use default"
if [ -f $ENV_DIR/VERSION_PIP ]; then
    export "VERSION_PIP=$(cat $ENV_DIR/VERSION_PIP)"
    echo "Use pip version: ${VERSION_PIP}" | indent
else
    export "VERSION_PIP=8.1.1"
    echo "Use default pip version: ${VERSION_PIP}" | indent
fi

echo "-----> Read VERSION_SETUPTOOLS from env vars, or use default"
if [ -f $ENV_DIR/VERSION_SETUPTOOLS ]; then
    export "VERSION_SETUPTOOLS=$(cat $ENV_DIR/VERSION_SETUPTOOLS)"
    echo "Use setuptools version: ${VERSION_SETUPTOOLS}" | indent
else
    export "VERSION_SETUPTOOLS=20.4"
    echo "Use default setuptools version: 20.4" | indent
fi


# create a symlink to where Python will be located when this slug is in
# heroku runtime, so paths in bin/ scripts generated by buildout are correct
mkdir -p /app/.heroku/
ln -s $BUILD_DIR/.heroku/python /app/.heroku/python

# configure environment to use Python compiled by heroku-buildpack-python
export PATH=$BUILD_DIR/.heroku/python/bin:$BUILD_DIR/.heroku/vendor/bin:$PATH
export PYTHONUNBUFFERED=1
export LANG=en_US.UTF-8
export C_INCLUDE_PATH=/app/.heroku/vendor/include:$BUILD_DIR/.heroku/vendor/include:/app/.heroku/python/include
export CPLUS_INCLUDE_PATH=/app/.heroku/vendor/include:$BUILD_DIR/.heroku/vendor/include:/app/.heroku/python/include
export LIBRARY_PATH=/app/.heroku/vendor/lib:$BUILD_DIR/.heroku/vendor/lib:/app/.heroku/python/lib:$BUILD_DIR/.heroku/python/lib
export LD_LIBRARY_PATH=/app/.heroku/vendor/lib:$BUILD_DIR/.heroku/vendor/lib:/app/.heroku/python/lib:$BUILD_DIR/.heroku/python/lib
export PKG_CONFIG_PATH=/app/.heroku/vendor/lib/pkg-config:$BUILD_DIR/.heroku/vendor/lib/pkg-config:/app/.heroku/python/lib/pkg-config

cd $BUILD_DIR
mkdir -p eggs  # zc.buildout expects this folder to exist

echo "-----> Pin pip and setuptools to versions set in VERSION_PIP and VERSION_SETUPTOOLS."
/app/.heroku/python/bin/pip install pip==$VERSION_PIP setuptools==$VERSION_SETUPTOOLS -U

echo "-----> Bootstrap buildout using Python provided by heroku-buildpack-python:"
echo "$(/app/.heroku/python/bin/python --version)" | indent
echo "$VERSION_SETUPTOOLS" | indent
/app/.heroku/python/bin/python bootstrap.py -c $BUILDOUT_CFG $BOOTSTRAP_VERBOSITY --setuptools-version=$VERSION_SETUPTOOLS

echo "-----> Run bin/buildout -c ${BUILDOUT_CFG} ${BUILDOUT_VERBOSITY}"
bin/buildout -c $BUILDOUT_CFG $BUILDOUT_VERBOSITY

echo "-----> Copy results to cache"
rm -rf $CACHE_DIR/eggs.tgz
rm -rf $CACHE_DIR/parts.tgz
#rm -rf $CACHE_DIR/bin
#rm -rf $CACHE_DIR/eggs
#rm -rf $CACHE_DIR/parts
#rm -rf $CACHE_DIR/var
#
tar cfz $CACHE_DIR/eggs.tgz -C $BUILD_DIR eggs
tar cfz $CACHE_DIR/parts.tgz -C $BUILD_DIR parts
#cp -r $BUILD_DIR/bin $CACHE_DIR
#cp -r $BUILD_DIR/eggs $CACHE_DIR
#cp -r $BUILD_DIR/parts $CACHE_DIR
#if [ -d $BUILD_DIR/var ]; then
#    cp -r $BUILD_DIR/var $CACHE_DIR
#fi

echo "Done" | indent
